<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"73bd9b55f419fea20f0e1e7a30af5627ad9474bbd7e8bb8e9d346e590fff813cbd136060a361e90d75f67d47142dfaca9cb1441e27d97f46399b4b08d37ebc2a4ded8841008fb52822143aa2cb21da8a42146181c981e5beeb292af3cfd5655ed742023572d2273aaba5247f4e11114fe7a9cfb59e2cd6f5c6cc0dac303227b8246f64546ce72939acc42e3129163992ddef6a05346a65304ca1108327851d7a22ea06aa076a1c0087dce6894b555e87891e58c63b8d5920966fc592706ab40c6fb133676943a216eb3adbb1a6619f98e4ca2c2d6c486c0a4418f5b8bdcd5557c0e9553b38ead53128792d3765f4d26d740a661e6a03dd1c70c874a17910cc16eb3f75af9ee0bdcb56e4f0b2594d53eda044d7a13059f93a104264264b4dfb885418a2568d7a2536e9119c03875f11e98147b8ea08fcb7ec5912a23a401a14beb59599eca0234012a4c68cef002b3f984973bdbb7c1511e16a6e825a05dc604a745d137b2d3d8770be322b615484d6775cd8c3c16c0f89e720020d8580da25363de1ae198eb7610ed83a752068587ec796b4c07a210a4620b8c74d76834d02c126249e4a5ed169f05ba541e434d71f7bb6a58470ef00ee402b0bd873e6480422c12c88126372cee882df52ed5e044c138e449c1cfef4f71accba57296a84d5a680f51d87f6882c54bc1eacc0e35d76846ef7a87bc0c71094c8476b017e6e418986ab37dd79dae4e421a0cd06ba5a2f7bff2e2834af3228cec88e729b799d4a153a8c9a280a344f41d22abde1069c0dccc4dfe8ca99a39ee2a4174a788f069bca2900d51ae51e25225f20535f9d2a8deaebec48c9b9072f75d0e94822beeb6da1da6365f262646ac92af40266bb3b7e7f8243b29893d781f7a4ba620dae049ee4a3d63501507598ddb87baf97b02efe065b7832ad06658dd966ec019980054faaef8f7bcd872995eeba3c1843a0bb09cec4625df81ef6d9076ebacaf9cf1f29a31df2e069fb46b5d8df84fae3141bde0ff6b930faf87458951e7d0846da5dd075a731c29e3c8e4f58f7c6187911d68dc693c47e6e0211f27e4e33ce56e5bc96c77e8eadd19230f99cda404ef8534181068cae35018fc99c492f143d5b046ec1c9d8c18a60ac60326a05165629c71e0b4b4bdfc3b3cfe04fea15c2f7076eb1e5e583377ce42dd90c2a93036932a106cc3beccefc64b9d043d74b97d92d3d79752581b186a9fc0dbb5431ba3f95d0afa875a78cb966a185029f2ce7109859efdc6a29456974b12bf1c4e1794d3a53a86cb71db22f1e872f58c2961cf0455df6ec69399db9224196c0fa652ebd0135f3d65a9d38753f58e78746d6c6001f60e67444c659537cc90817c9c9c6f010a0de80e0dbbf995eb68b4b2821d780540a00e85c3617fe6ba114d9e50237c525e3b4f73460b81ba372e3db49dcbe69def9cfd3ff19ac7e6d13a8679b5248b1110e358d95588085cec04d765b48765cb68f61e730a1f9bd2486fda9d9c68249a41e7898dfd99b4d0fba5a5a3a2d0a7ff2676b0ef4bfe51f3b852d6345c5ce151e05e31d80ad42af247b4d842702cc934d0739d107201aa09cd2705add0859b5be1f55c92562be203c0f47fc6efefaafa58b30f2109e3eb47b5533cfe52a0886d259d5b5966885bda6baa5e5d70ba5e71b49cfda0bfdc63740ee8476fda37dd26c830e46010390fa39960d06f8c342eb95c7e2f22d11dd0416ec0f90e51d9548eaebe58e27aa914e0744d468d112d7d90e71af2ff22033c3ed7eebff622e6a00bfa0c9fe377fd9c9a521af6508cc4f54c9dc598a58d993219c08f3d08b9526edb98037f3bc93bff49c4f1f8e51090f49ee6c7935a9c20c680fdb67435ea7a9576103ddcb1d1c182217e69d899699a924ec323bd015c007ff04037e1794d8905684b41958ea292b05dc1c4503546d123bea93428d255a558ab1f8f94743e26f807db8a3240509d83b38bb7258778efc70e5b61aaef8165016eda985552046655345e4b7a806c071b3436dfb55b5601125d1af7c32710b5f4ce689abbe65dde97b872f9035d159a9675da20aeaf547321d92e9f1c1dc8edd608745d805ec2aa295ae7d8dfe7882d0ae8300efd1510737cef115be3b3ae94407d3a27de7b3d558599cca4a7109c4897a7f61844e14ab183947ccb23a50aab984da95ca65ab6e3e8bf7493c74fcd5136a1834c1a1410c2f61cb9ec83d00993c8ec42a824728f38327a2c8545deefbd73665567abef9154d122bcaf941870c2c50cf5ca6005835780224eb724ea56eb721e96416dfda7e32015c3eef83f76a083b25ffc0d9258f194c3d993322c2c0ad2b7848d7d5ddcfc3f89a18c9d68fce87cc5247c31cd4f861ad3b276cf1eeafde4b04c4e64262226cf63f5d51a046e84bf8c7c048f48024befd89610f51885803674e4a353444cadc647ef1bbfa43988e3d9eda9cb3b2cffb8a2732279e1f8a008622aa6d1378780d6ecf75059dc15d1d10e4ec73e790ec7c2b33f22a72ed88b57ca3678dffc4313052337c28df02c5d1b3b91fae8f7351cf53a4019640013a5142d8e57a06cbd74a9b14ff113bdd3717d724c5cc0d671e1d1c3a908f63e326bc88ba0cbd9d2d469a03f66df7d2e3f6e9ebd26172baa43f33cdf86e4aea03f44f06cb3f3fe1f7cc4ab3597238e19b3d0365439c7f2fcead86cc2e862fc0178b5b1b28834aea56acfaa1688578f7e78dc83d349eebe035e925c78ade3f03ddd07230cb460d471ec5f9188bfbade30b9b6768ed7f9b341bdb05e2bdb029384f4cdf530775bc6391391e0d711498e7c07b72bfe95ed5278efd0252b2f5c7b114773be81f3bd7348cf803e07598547c72e3293a5f69814eb3a0cfc23e6145cff9515a3d3dd74fc16e0d94b6d8a1fdf2fed9e5cc93a46df84fdbe2baa2390656933003748aef9c4b85cbd23e9aaa4488b2710e67854713250eb6584632feefe862020b616a949c8e4c63c7a2ac486b722d9c42bb3fcf32caf64d05fcef4640dbdf4339021b7ac2bb65798eb0ccb99e3262ef6aeae066d8baa06012d1f925cf19812bcab0893a011c84de05678308de1a4dbad81722d4e9f9a607580c7d5b345f287c3f41c63301e0c6af1511eb2e34aab796698cc50c87e36bdf259ada09c1b48e14e7de69d22ad70c338e1e25e65fc51d738ff8167c6dd99cfb83da558084e64e259c93fd4b5cfe234e9ba0f73021d4c284b4fd4394c899e628dc21a10fce8d9a75db2d35cdbad8182cbac00229b94a22a46bde2fceb1f0d3c56a07b2180dd4890f32dea2c70b66a43517e4975f239a4bdc89fdb98719155c0d27675492db2e9d37ef778e22918d5da947af833e8722857db56d95f8c66d9fdee6c96a982dd3de08025d4e67d4a421b351ee3af5d658cef53ee25eefec5e45bfc152eb2cc88fbdb12665bb1c340700ab5c7163255be98ccc3689b0a9ba1b596a28d358764a51c173d4a4abf6e258808841c2259d72395458e750a38e5c0da6405af1ad85a93c5a51fb541ac31a24385b13892f403bbd6374990ba050bbde4448a803a2ea1dc0dfefcbb40ef6741686337de01e25a683ea3f40a132dd191f602492ca3df3c22d0e9d670202bbcafe651c36f94b5dbed77e356182b6b1a2ed2d09f613318a332a83ab6ddd1290e40a20f7c8caf06bfe8ef0b7cbacf837ab5170553d0a97197a090d5497ec1fa75c6ca5ca3739c569a884ccc648067714a6f0f4039cd3a98390829c8b8580571791b52c0933579d2f5c39b9e9e7da2ab1db6401939cbfcb22364dd37b3e380394f3a64f9c832f39a849604f3ef9490dd7aa71182d744cca0adf2a4af9a454fbf2ff54c0fef9b5d3ecf918cd71529bbd25bdc728f4eb8d3e2183bd637df698fb890563c3a4e8420b21129e2699cd35f56be31b13e1681bc378c64565ca9693e3895c09185afb98b14b6418a97d20252d6b58bdbdef0fe747bad27c302855c806b27f30c10c09b17c14f209dd5dd857091be01bd7a3e3db5e4d80d3704526048f5150c0fb2b7c77d777c248d00a965c727b8ab11cc398836c59a3cc1600e989063a9a9b8052c3b7cd0131a6d80ad73e073cbf27b9eba02cadcf3181774b8f9d49b47380cd77a6d2969d5e0072928148dfc865e12514bcb3559a467a8bd0c82d33d5e720fd9901f4a93fee3db382adf0e590b80957e8f127274338d031c5d3c172f625431ffaba544e787975c7100b1a4745b7d64cb2ee29d28d62a0835d2b92e85ac98b90af4615df8136b1ccc746a341dfa807319758b7477c16a260b452b3f66980be5d46f66792c3a32d721d298b717b26678c1bbf08946f94344c11475f3b294adb86da7c158044abd4709088618dfd61a30b6f2430374959fcbada514e82b8ae9d35e12f63ccf12ab223a3e0ecf532de1cb4556ead3283d92a3dbb24ce89510e21c41154357e6d1501e1de4883ab6cf21c7bcec1e9ddf3ce6dbc7c7db562ab838b22772afde54a483501b492f0675e33eb93b9da7cfc06d2861a1670e69ee6b33533885045103ba20f64809827fab471afc52bc1dcbe9bc3f974be886fb1beb3907381fecf316d25dd520c0f4d2855f2879ca169a8b7a673f9f61f2e714f1ee193f9114231aad9507c30b2844efbf288e1fd3a1bfeb28bf6d86a385d6aea8023db611325958273f79b0c29d3e1597bf88a4cfce1c58f81bdf852ad2c6d6053d7f6249dbfff0e1d06e381b1721a24459164eeccbed184c51a157fd5c395560ff9369e51304b2e09276260269f40df9e9be05c21e8e99d2fb73fb68bda5409a5afaafd28d68d1e6f392cdf541a9d6218191c6e97b33ccba86bcf9fcf96d534bcab9ff5a6bc2deecf6490ec034362724010553d2c7bff94568ab7346afedc76a428659a5c56d6413fd2bfb3269ce80336e402305d984b096b2ff2ef99cf4e82010c2168867a37b8731eade025d8e89652c54e698b9bb179cd672a9ca2715a63b97147953695c5f2dc0a05e6e9f0606b1c6719d69e68178d5eb3e7d21e476282c65e3b995f591bb5fbea32e15fdc1de43bd4da9768c61222f51f284e0c1712f415dadc3882d7004e6bc4422b95393af48e773c0cfb3d7adc8f176b717be21bbf8fb383bd87dbbd08b3d0337606746578654572f0997e9119af3c6956efc389e3da5c23069ed87cf2d0b44643afe38d4ee857ec6d637b4dea40fc17c6a5b70e63c50b2d7a5e91a91bb8a0aded8a6eecaef1e4790d012d6f0333b794d379972a9b19192f4c4d0775a6786c97fa43257a231114d7c0fee0487b654f7b534eb800d73c89aeff3507fbdf3e076f7c95f15386969a574c62c38785544887eb8e94d21485afad051ec2670df3a2e2e94b25e45a28cba3250963e390049f380e608cfea42110ca1793c307bcfaf34d88c8e5e3315628796a8f3b0d602e994af530eed66f85d0422cb610f3fef7d4a55458a003a743b8e2a9242228597b74381f4c3b4d5ad08455a32ab876d8af26488a031e19cdd97e7c4ebb7e04669b32931070670ba3eeada65e882f77dd515f33e30ba3dcdb66ced28cee3576bcc70337d2eb2d6986b44cb0153c8b3759d8b4eba867952b5706dc913e65ff0c91d5d238f82ba751a7402d7932e52b3bb256300ae6222fe08957bf047ce21f187cfc85b4a2605fdec8de94bbd10b7834c5f393fcccc44bc945baacec2cc11d5d324af9d7febc59a2d7a13af531724479b8ad158b210fae635cf5b4be6e5cc1e7cced46409190a9c772b839a2a979c179f89db52221928b10c3108849bcbf35cf1e1d33d9bd4285450c53b1f7e8d80b5213946a573840fdd63310c8c509d144bc6ec8b0a73d2c1c28dd8968157ddb88aa19529ed290fb0cc05b9282eaf8aeaec45efea573e685ca1f90400b0766a9104dd58db818458397f92a45a42c473140f573e16c6c8555986d529bcc64be17d44fc474d4104d19763e1bd08f88efddd612011832f9ba044026d8bc031501f6c65dcec885cadf3c608adf7fd5f3892140df973c5a2482809a9d5728edf9576b31d2c7dcfb47c85c771f953b346b935f778b0e4e91211dd7222c5141182daf0368fe8d70d4f554fde8eff8c3380e74dd4ebc8ff30f7ec874349c5452659d544597e5fc27a37547bd416a592be39e9bea46c08178220fccec8b456e8da366edd2fc27d696b9f137e03c46745b35ceebd84e03f5b634b7792be2c02a17bce1b70187d4fc1f81ecf08b6301ccb2d9a8c3f4141d2616c0b61042995eca3a0f363ce849c7aa4c99085378151d0e96a400dc87534e4a43d505eb3217cce3dc67697c2a17df709363bfceece83e2d3ae4384a9bb78d910d8e9227b8cae655d6d4a78bad2c3b0bf3d081dba2dc78316a039b2cc1b414e718fc8605bae1f5299f9410d093e778f4e7a89732c4b89094ac57aecd9bcd850670b366db01cb3a778dd9bb0ebecb4a97305b1387bf6947c31b86668ab0bbb823bf56005251c620ebb86fc353d58ec13b2ef7217196aadbfda85a07f3455caa941cb5f4283c72b9f46de5df3c1815473b5ce46c639daa725cad8e381fc7d3deabc7f711697371e84cfeeea9d2de861c54c33020ae509103f5d8baca6cd538dfaa4c833c2c902474e1279ec777fd8625dc0020b07028f84ea7bf1e34d23d95235e84d25dd4c7c9f0c44163c1555f5b0465d64daa2bda0e47675d086f94c5e193908f71df5da1d09fd8c2f0baff3239488296de288dbd52e73a8f790028dff3c3711eb0b83cc8c1771f6975a5a9dab7dd19c27f90a1a578d0756f823dd6542e969de35b5d1e5dfc1089e20750f54a9e894611a0cf50cb6df2e3381874eeb45ac08663d6aa56617f46939955b035759a9f48c830edf343df6f292785cc0b6a6a2187c59224af168df22b15ba1462efd44a023acd997ad81f8a636f7118d83d1f443a05bcb8c890a3c070a95615fcc7212283b4550bd4012f19fcb147d5e8283614a86cb1f632b9265968929856a6be19c152da576d38862c55adfc3f1e70f92136d2a05776525a1bf5737af034d6649726009ed4eca3a4da3435d75c96e504161fcb9abf6439270f2d5c2afb7bb10004db5861b57e458b898ea81af0a724abe93e1e5232e8b85463d50b5ebe80b32faaa33f194c72f801b971c3da6370d818d66af1e148e5486543fe7368921775068c5cc3d909bf3bec4f77a14b48efafe62588c256e7c4feda09dd88fbdcf157dd615b4449fb150c218eab1cac69595c169c4c2689a98b300215e1083095ac4f1e40333ed623a351b294900b38f35513f94349449a897ade8bc1a0470295044e7702e5e0b7ea88851fb711a0cea7817ea1af92c250fd1e579ecb9dbde28758598615545113515493bc2ec1c066b331a8559360919cfda6cdf7a99475fbf87d485a6284c4cb1351727a872e6d7021d12569594e7e6df86a47752ed31031d5731987a93f291c6c0e6b966393e25d1c7d9358bfc9e2e0e0997ae111eed62d46e9cac2aa78c053003d799f1f0464cfaf2640f01d9bb3950c693e36c50fa343fdaa6b3085da9d48cec6ce83d7a35048d8ff5af3dff183e5c83ee4985be90e4f48dd0b7a690329a79252e90108b1c3550010c92119f77a16fae1c9d8747670884a46ff50a885451e3946e5924c7720e17ea632f31f5c9c2880f549c6473affc780f36e6765b9f6f3a53378f7c7699b7a7f86865a46e0bd66d9579d24b599dbaedbd1f9103e634ec5620e27decefb2abf753872bf7d93defcc88cf5dec87d70ce20058d87143bf3589c7c0f6f5b705117b5a138e95b588a600fe72d416acc1ff867ec1fcc8965f3695b4d920d1d63072e3cc564957f688279ec93d8c05b80aeb93f7dd4cf5ed3da690c66f743997603c5df2f6fd07ee0335bebab9102b5c5e66b85590b84494ee898d05a73c3d9c5626d7c3e8f873162dc3e63f4d63713edeb83785005835ee409db9803850d862467e5c36bc10df5448810fc4e37848b89e8ca87fe170d5d1b4035fab7a02b78c12784c75a9840b337b29809955d3e4d09d3d433916e1a8548cdb088eb52671253840162908fd0e1da1069e325423d6ba1c0c9e4f7ad618968e6a3b019afd413143b7673f2c23837602910ef06f1b2a12bca4ff3e882a3f216623985359061c563cf78a61894391b299c6e7142d938cd2fd31d327880c9c3d14d682d8eed29f65bd415c2a473b4c0d196c97feafd821e90d641295895d5853f2d742b65b5670c17db6651ead880ce07baeeace59cc9f462f21f067ea7f331d70186d563cfb3501159fe1ad64eb040e05c5ccb2d393f7b42a55d7005a37b7eca85c3c78cade3e208a8bb6b81fb835906cc3f2cf5e0b9d2f3a008eef67318fc085d6e4656f5dc89aa761934a52189b3844d6a24cb240f5416e9ec75fe009c1822a05fb3e2ab76825c5421d106fa75953fd598835ad870b3e2d5bc9095d5f640a413d92bd62357d72b9263d64317d0c3cda79066764c31717fee5d59d2f3d896e65cd5992309dbfcd832ddc1c406bd69da261ac0aac8607cc14428a0542d50b795ce81a098de628bb55839523b69323a71117f8e691225091a73962c872add4498ede7cb3d8f8da416c946c3b44c64b9c6559114ab404c3453767809eb853b784ea9d70fbc3a2ca58e107a9dcc9808b8c460e66996da05457a0e563d6ce4e7472be336426f727ad8a1e11b9642237d0366431a189fddf3df11f474b0056dafb9226a8471f70ae84c7a9023213c27bf20220bd0f7f9fb1aebfbd348d960510d08cf460e7525409e2f56f915bdd672904cb82ef7001a8f46fe1156064083aa7bf0cd0ef71cec607abc9084f17a3ee132747793bd4675e37c6e1bbb141920bc6812cea9949198b30213f019e1b06cff07acfd3e730c68adb00df4272a88ea2ecca90187378125f307e05be71ce71be1e4b159b55135cc46be391ed81bd84df809be40c17303ca18e01ad34148dac01129a62f3b77423ba3876f480ed4e5142657a52e4ef80222f93fe57410840feac633acedac64f1915227dfce0810e34c742bd2bbf24fe09460513e3d35a5afb0752740bc510f67b558c7021db38ca80e47b4c5a8c24fe733616b872575b0cf05a2ab0c6e3bad878e28eaf7e2c66f6c042443bf95c6171a7cfb1423ccf75ed8e81ee0ceeb68f79f41b81a0900cf6552a42ba428f29a3a9c1c7f45bd3f17423bf0d098586c03e95fb17e425e5a3e351f404ddd3505e50bb58d2d5083e42c2bbde7ee5f362585502656ecce19cff7b9cf96f00b27c57005ed12864622235639dcf76a4e802e40e51b4aea","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a45a68ae4dc769e93909d6e3437e3352"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
